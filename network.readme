todo: 

1) reboot, exit to shell and shutdown all work for clients and server, except
	exit to shell doesn't work for server (not that I would ever want to exit to shell on server tho)
2) input for motion sensors (use odata database?)
3) if both win clients are up one should be doing some things - have a way for win clients 
	to talk to each other 
4) days in client gets reset from 2 to 1 (happened just once)
5) strlen() in some msg's may not send data w/ 0's 

to add new commands:

1) add to the enum in cmd_types.h 
2) add to load_cmds.c 
3) inc the NO_CMDS define in mytypes.h 
4) copy to multi-client.zip (pack) 
5) ssh out to 148 
6) unzip -o ~/multi-client.zip into ~/dev/multi-client directory 
7) go back to either thread_client or thread_server and 
	compile as usual 
	
When changing the number or order of clients:
1) make sure ClientAvail.xml is updated 
2) line 240 in FrmSampleClients.cs needs to be changed:
	clients_avail[8].socket = 1;        // 8 is _SERVER (this is bad!)	
3) The collection field in the combobox of clients in ClientDest.cs 
	needs to be changed or the timer stuff won't work 

'next_client' in tasks.h is used for when client sends msg to other client 
each client needs to keep track of what other clients are logged in so it
can set the 'next_client' to the next one logged in. If 'next_client' is 
set to '0' - currently, the win client sets which client sends to which.

can't send/recv more than 255 bytes using send_msg() or get_msg() (TCP)
If server gets msg to shutdown, reboot, etc. then it must log off all 
clients 
If client(s) gets msg to shutdown, reboot, etc. then server stays up 

In the first case all the commands would be in the cmd_types.h and would 
be limited to 255 total commands. 

146 (server) is where the pi used to be (controlling garage lights)
154 is cabin
147 is other io card in garage near RE system 
150 not used 
151	"
155	"
145	"

when sending array of bytes from WinCl to svr/cl 
array must be 2x what's needed 

	byte test = Convert.ToByte(tbTest.Text);
	byte test2 = Convert.ToByte(tbTest2.Text);

	byte[] bytes = new byte[8];
	bytes[0] = test;
	bytes[1] = test2;
	bytes[2] = 7;
	bytes[3] = 9;
	AddMsg(test.ToString());
	AddMsg(test2.ToString());

	string cmd = "DB_LOOKUP";
	int offset = svrcmd.GetCmdIndexI(cmd);
	svrcmd.Send_ClCmd(offset, 3, bytes);


OUTLINE OF SERVER

WinClReadTask gets msg from windows client 
	if dest = client send tcp msg to client 
	if dest = server send msg to sched_qid get_host_cmd_task (cmd_tasks.c) 

	get_host_cmd_task of sock_mgt:
		sock_mgt: msgrcv(sock_qid...
		send msg to sched_qid
	get_host_cmd_task of sched:
		cmd_tasks: msgrcv(sched_qid...
		send msg to sock_qid
		
ReadTask (1 for each client) 
	recv_tcp(client_table[index].socket...
	if dest = server 
		msgsnd(sched_qid...
	if dest = client, 
		send_msg(client_table[dest].socket... (tcp)

OUTLINE OF CLIENT

get_host_cmd_task2() in cmd_tasks.c of each client waits for msg from sched:
	msgrcv(sched_qid...
		can send msg via send_sock_msg() which does: msgsnd(sock_qid...
	otherwise does IO 	

recv_msg_task in sock_mgt waits for msg: msgrcv(sock_qid...
get_host_cmd_task1 in sock_mgt waits for tcp msg and sends to 
	sched in cmd_tasks.c: msgsnd(sched_qid,