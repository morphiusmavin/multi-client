todo: 

1) reboot, exit to shell and shutdown all work for clients and server, except
	exit to shell doesn't work for server (not that I would ever want to exit to shell on server tho)
2) input for motion sensors (use odata database?)
3) if both win clients are up one should be doing some things - have a way for win clients 
	to talk to each other 
4) days in client gets reset from 2 to 1 (happened just once)
5) strlen() in some msg's may not send data w/ 0's 
6) SEND_CLIENT_LIST from cmd_tasks to sock_mgt shouldn't need any params (line 306 in cmd_tasks.c) 

to add new commands:

1) add to the enum in cmd_types.h 
2) add to load_cmds.c 
3) inc the NO_CMDS define in mytypes.h 
4) copy to multi-client.zip (pack) 
5) ssh out to 148 
6) unzip -o ~/multi-client.zip into ~/dev/multi-client directory 
7) go back to either thread_client or thread_server and 
	compile as usual 
	
When changing the number or order of clients:
1) make sure ClientAvail.xml is updated 
2) line 240 in FrmSampleClients.cs needs to be changed:
	clients_avail[8].socket = 1;        // 8 is _SERVER (this is bad!)	
3) The collection field in the combobox of clients in ClientDest.cs 
	needs to be changed or the timer stuff won't work 

'next_client' in tasks.h is used for when client sends msg to other client 
each client needs to keep track of what other clients are logged in so it
can set the 'next_client' to the next one logged in. If 'next_client' is 
set to '0' - currently, the win client sets which client sends to which.

can't send/recv more than 255 bytes using send_msg() or get_msg() (TCP)
If server gets msg to shutdown, reboot, etc. then it must log off all 
clients 
If client(s) gets msg to shutdown, reboot, etc. then server stays up 

In the first case all the commands would be in the cmd_types.h and would 
be limited to 255 total commands. 

146 (server) is where the pi used to be (controlling garage lights)	(offset 8 in client_table[])
154 is cabin	(offset 2 in client_table)
147 is other io card in garage near RE system (testbench)	(offset 3 in client_table)
150 not used 
151	"
155	"
145	"

when sending array of bytes from WinCl to svr/cl 
array must be 2x what's needed 

	byte test = Convert.ToByte(tbTest.Text);
	byte test2 = Convert.ToByte(tbTest2.Text);

	byte[] bytes = new byte[8];
	bytes[0] = test;
	bytes[1] = test2;
	bytes[2] = 7;
	bytes[3] = 9;
	AddMsg(test.ToString());
	AddMsg(test2.ToString());

	string cmd = "DB_LOOKUP";
	int offset = svrcmd.GetCmdIndexI(cmd);
	svrcmd.Send_ClCmd(offset, 3, bytes);


OUTLINE OF SERVER

WinClReadTask gets msg from windows client 
	if dest = client send tcp msg to client 
	if dest = server send msg to sched_qid get_host_cmd_task (cmd_tasks.c) 

	get_host_cmd_task of sock_mgt:
		sock_mgt: msgrcv(sock_qid...
		send msg to sched_qid
	get_host_cmd_task of sched:
		cmd_tasks: msgrcv(sched_qid...
		send msg to sock_qid
		
ReadTask (1 for each client) 
	recv_tcp(client_table[index].socket...
	if dest = server 
		msgsnd(sched_qid...
	if dest = client, 
		send_msg(client_table[dest].socket... (tcp)

OUTLINE OF CLIENT

get_host_cmd_task2() in cmd_tasks.c of each client waits for msg from sched:
	msgrcv(sched_qid...
		can send msg via send_sock_msg() which does: msgsnd(sock_qid...
	otherwise does IO 	

recv_msg_task in sock_mgt waits for msg: msgrcv(sock_qid...
get_host_cmd_task1 in sock_mgt waits for tcp msg and sends to 
	sched in cmd_tasks.c: msgsnd(sched_qid,
	
old way
	server sends AREYOUTHERE msg to win cl 0 every second 
	win cl puts the seconds server is up in tbServerTime edit box 
	and sends YESIMHERE back to server but server doesn't do anything 
	with it 

new way 
	use START_TIMER/STOP_TIMER msg's to send AREYOUTHERE msg to 
	individual clients for specified period (1 sec, 2 sec, 5 sec) 
	client then responds with its time stamp and server calculates 
	how long it took to respond 
	
there's no lag with client in cabin using a wire across the ground 
as opposed to using the TP-Links. 

system needs to know what time it is (use system time functions) but 
also have a list of sunrise and sunset for the entire year so e.g. it 
can know when to turn lights on/off in chicken coop to extend laying 
time for hens and turn on night lights at dusk. 

Assign functions (easy button) should be able to do multiple lights.
Show on function assign dlg what is assigned to each function, if any.

Have a to-do list built in. Also maybe a git list.
	
ethernet wire colors 
used:
3	light green
6	green 
1	light orange
2	orange 

not used:
5	light blue
4	blue
7	light brown
8	brown 

clients 
get_host_cmd_task1 (sock_mgt.c) -- gets msg from tcp and passes it on to get_host_cmd_task2
	
	recv_tcp(&msg_buf[0],msg_len+1,1);
	...
	msg_snd(sched_qid...) 
	
get_host_cmd_task2 (cmd_tasks.c) 
	msg_rcv(sched_qid...) 
	
a) turn ports on/off over a 24 hour schedule with multiple on/off times 
b) turn ports on/off depending on a temp reading 
c) turn ports on/off depending on 24 hour sched but with sunrise/sunset data 


new way:
typedef struct
{
	int index;	// key for each record
	int type;	// 0 - not used; 1 - a; 2 - b; 3 - c (above)
	int port;	// which port (0 - 19)
	int var1;	// the meanings of these depends on the type 
	int var2;	// type 1: on_hour, on_minute, off_hour, off_minute
	int var3;	// type 2: on_hour, on_minute, seconds to stay on, minutes to stay on
	int var4;	// type 3: turn on temp, turn off temp (only var1&2 are used)
				// type 4: time to turn on before sunset, on after sunset, off before sunrise, off after sunrise
	char label[30];
} CMD_STRUCT;

old way:
typedef struct
{
	int type;					// 0 - short duration; 1 - long duration (on/off hours minutes)
	int port;					// which port to turn on/off
	int on_hour;				// use this if type 0 or 1
	int on_minute;				//	"	"
	int off_hour;				// use this if type 1 only
	int off_minute;				//  "  	"
	int duration_seconds;		// use these if type 0
	int duration_minutes;
	char label[30];
} CMD_STRUCT;
