todo: 

1) input for motion sensors (use odata database?)
2) if both win clients are up one should be doing some things - have a way for win clients 
	to talk to each other 
3) Hook up temp sensors and use as triggers for ports (heat strips) or warnings 
4) Clients/Server should send a msg back to Winclient after Winclient logs in saying that they 
	already have their time set 
5)	Had to disable monitor_fake_input_task() because of 'bad mask 1' error 
	monitor_fake_input_task reacts to change_input() used in old Truck_Project1 
6) Move coop heaters, lights & outdoor lights to 147, replace 147 w/4600 and put 150 in NW corner 
7) be nice if clients could just log off (but how they gonna log back in?)
8) win client is now eating up memory for some reason (not too bad - keep an eye on it)
9) try getting the mqtt library working with the 4600 cards
10) need a config file for each client/server which stores:
	a) params for DS1620: enabled, which ones are valid, frequency of samples 
	b) 
11) instead of having a timer to turn lights off in Garage/Cabin dialog, make it a function of 
	the client/server that sets it's own timer to turn off the lights using the timer schedule 
	sort/timer_task method (done except the state on the properties are not changed)
12) Need an all-off button for cabin (F5?)
13) Use push buttons hooked up to inputs on 146 to turn on/off lights in garage 
14) Use config.bin to store variable that tells how often to rename ddata.dat. (the dat file 
	for temperatures)
15) Need a way to monitor ddata.dat size (ds_index) 
16) Need to be able to monitor the cdata.dat & ddata.dat files from the wincl only and not the tty (mostly done)
17) nice to have advanced warning when sched is about to execute lights on/off (in timer_task)
	(poss. have the lights blink off and back on a minute before going off)
18) need a new msg that the client sends back to wincl so it can update the state of the lights buttons in 
	the properties settings (also, some of the dialogs don't show the button's correct state when re-entering
	the dialog 
19) client_table[] is not updated in sched as far as who's logged in (client_table[].socket)
20) if 2 win clients up (see #2) then there should be a way the buttons can be toggled to reflect what's 
	been changed on the other win client
	
	the server (146) when starting up reads a file called: address_list.txt (in assign_client_table.c) 
	this specifies the 1st and 2nd windows clients along with all the rest of the TS-4600 clients.
	Then each 2nd windows client (todate there are only 2: Win7-x64 and WINDOWS-11A) must be in the 2nd line.
	On top of that, the C:\Users\Daniel\ClientProgramData\ClientsAvail.xml must have the local machine and 
	ip address on top and the other windows machine in the next xml entry.
	
	
to add new commands:

1) add to the enum in cmd_types.h 
2) add to load_cmds.c 
3) inc the NO_CMDS define in mytypes.h 
4) use peazip to make tar file 
5) ssh out to all
6) run do3.sh on all
	
When changing the number or order of clients:
1) make sure ClientAvail.xml is updated 
2) line 240 in FrmSampleClients.cs needs to be changed:
	clients_avail[8].socket = 1;        // 8 is _SERVER (this is bad!)	
3) The collection field in the combobox of clients in ClientDest.cs 
	needs to be changed or the timer stuff won't work 

'next_client' in tasks.h is used for when client sends msg to other client 
each client needs to keep track of what other clients are logged in so it
can set the 'next_client' to the next one logged in. If 'next_client' is 
set to '0' - currently, the win client sets which client sends to which.

can't send/recv more than 255 bytes using send_msg() or get_msg() (TCP)
If server gets msg to shutdown, reboot, etc. then it must log off all 
clients 

In the first case all the commands would be in the cmd_types.h and would 
be limited to 255 total commands. 

146 (server) is where the pi used to be (controlling garage lights)	(offset 8 in client_table[])
154 is cabin	(offset 2 in client_table)
147 is other io card in garage near RE system (testbench)	(offset 3)
150 is io card (outside) (offset 4)
151	" offset 5
155	" offset 6
145	" offset 7

146	8
154 2
147 3
150 4

* may want to have 150 at the nw corner of the garage and have a sep relay board outside for 
	the chicken coops - run the 12v supply out to the relay board as signals for the relays 
	and use 147 for the chicken coop and outdoor lights

when sending array of bytes from WinCl to svr/cl 
array sent must be 2x what's needed 
cl/svr will have a msg_len of 2x but only 1x of data 
e.g. 

	byte test = Convert.ToByte(tbTest.Text);
	byte test2 = Convert.ToByte(tbTest2.Text);

	byte[] bytes = new byte[8];
	bytes[0] = test;
	bytes[1] = test2;
	bytes[2] = 7;
	bytes[3] = 9;

	string cmd = "DB_LOOKUP";
	int offset = svrcmd.GetCmdIndexI(cmd);
	svrcmd.Send_ClCmd(offset, 3, bytes);
	
msg_len will be 8 but data recv'd is only 
test, test2, 7 & 9

OUTLINE OF CLIENT/SERVER SOCK/SCHED

both client and server use same copy of cmd_tasks.c & tasks.c 
in main directory (dev/multi-client)
the differences are determined by the #ifdef/#endif statements
so the sched for both are essentially the same but the 
handling of sockets are in sock_mgt.c of the thread_client & 
thread_server directories - the sched.c handles the startup & shutdown 
of the sched program while the sock_sched handles the startup & shutdown 
of the sock_mgt. The sched program does all the hardware type work like 
the ports for the io card and serial ports.

get_host_cmd_task in cmd_tasks.c: 

waits for msg from sock_mgt:
if (msgrcv(sched_qid, (void *) &msg, ...
does switch/case and can use send_sock_msg() to send a message back to 
the sock_mgt 

get_host_cmd_task in server's sock_mgt wait for msg 
from sched:
if (msgrcv(sock_qid, (void *) &msg, ...

it can either send a msg back to sched, to one of the clients 
using the tcp send_msg() or to the windows client using send_msgb() 

get_host_cmd_task in client's sock_mgt waits for msg 
from tcp and relays it onto the sched with no switch/case
statements like the server's get_host_cmd_task does

UCHAR recv_msg_task() in client sock_mgt waits for msg from sched and 
relays it to tcp (send_msg())

the get_host_cmd_task in the server's sock_mgt has switch/case statements 
while the get_host_cmd_task in the client's sock_mgt just relays the 
messages onto the sched 

WinClReadTask gets msg from windows client 
	if dest = client send tcp msg to client 
	if dest = server send queue msg to sched_qid get_host_cmd_task (cmd_tasks.c) 

	get_host_cmd_task of sock_mgt:
		sock_mgt: msgrcv(sock_qid...
		send msg to sched_qid
	get_host_cmd_task of sched:
		cmd_tasks: msgrcv(sched_qid...
		send msg to sock_qid
		
ReadTask (1 for each client) 
	recv_tcp(client_table[index].socket...
	if dest = server 
		msgsnd(sched_qid...
	if dest = client, 
		send_msg(client_table[dest].socket... (tcp)

need to know the destination because it's used by ReadTask in server 
	
idea for detecting if client is still up:
	use START_TIMER/STOP_TIMER msg's to send AREYOUTHERE msg to 
	individual clients for specified period (1 sec, 2 sec, 5 sec) 
	client then responds with its time stamp and server calculates 
	how long it took to respond 
	
there's no lag with client in cabin using a wire across the ground 
as opposed to using the TP-Links. 

ethernet wire colors 
used:
3	light green
6	green 
1	light orange
2	orange 

not used:
5	light blue
4	blue
7	light brown
8	brown 

clients 
get_host_cmd_task1 (sock_mgt.c) -- gets msg from tcp and passes it on to get_host_cmd_task2
	
	recv_tcp(&msg_buf[0],msg_len+1,1);
	...
	msg_snd(sched_qid...) 
	
get_host_cmd_task2 (cmd_tasks.c) 
	msg_rcv(sched_qid...) 
	
a) turn ports on/off over a 24 hour schedule with multiple on/off times 
b) turn ports on/off depending on a temp reading 
c) turn ports on/off depending on 24 hour sched but with sunrise/sunset data 

Use SunriseSunset.exe (C:\Users\Daniel\dev\SunriseSunset\bin\Release\SunriseSunset.exe)
to compile tdata.XML to be used by EpServerEngineSampleClient.exe (Windows Client) 
1) goto https://www.timeanddate.com/sun/@43,-104.803?month=10&year=2022
	(in this example for Oct 2022)
and scrape the spreadsheet starting with '1' to the left of the first sunrise date 
2) paste it to a text file called: tdata[x].csv in C:\Users\Daniel\SunriseSunsetData
	where 'x' is the number of the month (Jan = 1)
3) do this for as many months as you want to catalog
4) goto sunrisesunset.com -> 'Selected U.S. Cities more' -> Wyoming -> 
	chose Manville as location -> choose month/year -> 
	check 'moonrise' & 'moonset' -> 'Make Calendar'
5) scrape webpage of calendar and save to text file called: 
	C:\Users\Daniel\SunriseSunsetData\[xxx].moon where 'xxx' 
	is the name of the file for that month (e.g. Dec.moon)
	do this for as many months as you want to catalog.
6) run this app (C:\Users\Daniel\dev\SunriseSunset\bin\Release\SunriseSunset.exe), then 
	choose the month, then hit 'Open CSV' to create the 
	xml file for as many months to catalog.
7) Then choose the month in the month pull-down, then choose 'Open Moon' and choose 
	the *.moon file(s) you want to add to the list.
8) Show Cdata will show all the data from the xml files with the moonrise & moonset 
	columns blank.
9) 'Add Moon' will add in the internal moon list to the internal sunrise/sunset list 
10) Show Cdata again should show both internal lists as the same.
11) 'Create Final XML' will output the entire list to an XML file of your choice.
12) move that file to: ClientProgramData\\tdata.xml to be used for MagicMirror
	
relay modules:
middle: common 
left: no 
right: nc  


/*
	for(i = 0;i < 40;i++)
	{
		printf("%d: %d %d\n",real_banks[i].i, real_banks[i].bank, real_banks[i].index);
	}
this outputs the following:
0: 0 0		// start of 1st card
1: 0 1
2: 0 2
3: 0 3
4: 0 4
5: 0 5
6: 0 6
7: 0 7
8: 1 0	
9: 1 1
10: 1 2
11: 1 3
12: 1 4
13: 1 5
14: 1 6
15: 1 7
16: 2 0
17: 2 1
18: 2 2
19: 2 3

20: 3 0		// start of 2nd card 
21: 3 1
22: 3 2
23: 3 3
24: 3 4
25: 3 5
26: 3 6
27: 3 7
28: 4 0
29: 4 1
30: 4 2
31: 4 3
32: 4 4
33: 4 5
34: 4 6
35: 4 7
36: 5 0
37: 5 1
38: 5 2
39: 5 3
*/

using SET/SEND_CLIENT_LIST 
to set 1 client to send msg 
to the next 

case SET_NEXT_CLIENT:
	next_client = tempx[0];
	if(next_client == 7)
		next_client = 0;
	printf("next client: %d\n",next_client);
	j = 0;
	break;

case SEND_NEXT_CLIENT:
	cmd = 0x21;
	for(i = 0;i < SERIAL_BUFF_SIZE;i++)
	{
		tempx[i] = cmd;
		if(++cmd > 0x7e)
			cmd = 0x21;
	}
	send_msg(200,(UCHAR*)&tempx[j], SEND_MESSAGE, next_client);
	uSleep(0,TIME_DELAY/10);
	send_msg(1,(UCHAR*)&tempx[j], SEND_NEXT_CLIENT, next_client);
	j++;
	if(j > 10)
		j = 0;
	break;


git ls-tree --full-tree -r --name-only HEAD

on board with door meant for NW corner, the converter board to the left 
of the TS-4600 board has 8 wires from DIO1 starting from the right w/ 4

DIO pins on bottom right of card when 
looking down at it with eth port to 
the right

gnd	x	x	15	x	x	x	x
14	13	11	10	8	7	6	4

pin 4	DQ
pin 6	CLK
pin 7 	RST_0
pin 8	RST_1
pin 10	RST_2
pin 11	RST_3
pin 13	RST_4
pin 14	RST_5
pin 15	RST_6	// probably won't use this - 2 conv chips 
				// make only 8 lines 

this was in get_host_cmd_task of cmd_tasks.c but not being used 

/*	testing how the winCl sends ints & longs 
				case DB_LOOKUP:
					printf("tempx: %02x %02x %02x %02x\n",tempx[0],tempx[1],tempx[2],tempx[3]);
					long temp = pack4chars(tempx[3],tempx[2],tempx[1],tempx[0]);
					printf("%d\n",temp);
					break;

testing how winCl sends var. no. of bytes 
				case DB_LOOKUP:
					printf("tempx: %02x %02x %02x %02x\n",tempx[0],tempx[1],tempx[2],tempx[3]);
					trunning_days = tempx[0];
					trunning_hours = tempx[1];
					trunning_minutes = tempx[2];
					trunning_seconds = tempx[3];
*/


511 - 403 - 108
so tval represents the entire possible temp range of the
DS1620 from -66F to 257F in a range of raw values from 0 up to 
359 but because any temps from -66 to 32F are raw values from 
403 to 511 then it's not trivial to have an algorithm that 
throws out any outliers and does any graph smoothing

			if(fval >= 0.0 && fval <= 250.0)
			{
				C = fval/2.0;
				tval = fval + 109;

			}
			else if(fval >= 403 && fval <= 511)
			{
				C = (fval - 512.0)/2.0;
				tval = fval - 403;
			}
			F = C*9.0;
			F /= 5.0;
			F += 32.0;

*/

int reduce = 0;
private void tsbtnReduce_Click(object sender, EventArgs e)
{
	int i = 0;
	int j = 0;
	int k = 0;
	j = mycdata.Count() / 2;
	for (i = 0; i < j; i++)
	{
		if (reduce >= mycdata.Count())
			break;
		mycdata.RemoveAt(reduce);
		reduce++;
	}
	AddMsg(reduce.ToString());
	reduce = 0;
	RedrawGridView();
	return;
}

Using STM32CubeMX to generate code for STM32F407:

Under Project Manager->Project set project name and 
set Toolchain/IDE to STM32CubeIDE 
Under Project Manager->Code Generator check 
"generate prepheral initialzation as a pair...

Under Pinout & Configuration goto Middleware and Software Packs 
and enable FREERTOS and go to Advanced Settings and enable 
USE_NEWLIB_REENTRANT then goto System Core->Sys and set 
Timebase Source to TIM1 or something other than Systick 

To get STM32CubeIDE to compile hex file instead of elf:
goto Project->Properties->C/C++ Build->Settings and then 
the Build Steps tab and in the Pre-Build Steps Command window:

arm-none-eabi-objcopy -O ihex ${ProjName}.elf ${ProjName}.hex

